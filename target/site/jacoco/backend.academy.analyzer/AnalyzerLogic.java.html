<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnalyzerLogic.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java</a> &gt; <a href="index.source.html" class="el_package">backend.academy.analyzer</a> &gt; <span class="el_source">AnalyzerLogic.java</span></div><h1>AnalyzerLogic.java</h1><pre class="source lang-java linenums">package backend.academy.analyzer;

import backend.academy.datefilter.DateFilter;
import backend.academy.nginx.NginxLog;
import backend.academy.statistic.Metrics;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.LongSummaryStatistics;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Класс AnalyzerLogic предоставляет функциональность для анализа логов Nginx.
 * &lt;p&gt;
 * Он собирает статистику о размерах ответов, количестве ресурсов и кодах ответов.
 * Класс поддерживает выборку логов для более эффективного анализа, а также
 * может анализировать логи с учетом временных фильтров.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Основные характеристики:
 * &lt;ul&gt;
 *     &lt;li&gt;Сбор статистики по размерам ответов с использованием {@link LongSummaryStatistics}.&lt;/li&gt;
 *     &lt;li&gt;Подсчет количества обращений к различным ресурсам с помощью {@link HashMap}.&lt;/li&gt;
 *     &lt;li&gt;Подсчет кодов ответов HTTP и их частоты.&lt;/li&gt;
 *     &lt;li&gt;Поддержка выборки логов для уменьшения объема обрабатываемых данных.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 */
@SuppressWarnings(&quot;LambdaParameterName&quot;)
<span class="fc" id="L38">public class AnalyzerLogic {</span>
    private static final int NUMBER_OF_TOP_RESPONSE_CODES = 3;
    private static final int NUMBER_OF_TOP_RESOURCE = 3;
    public static final int SAMPLE_SIZE = 5000; // Размер выборки
    private static final double SAMPLE_PROBABILITY = 0.1;
<span class="fc" id="L43">    private static final Random RAND = new SecureRandom();</span>
<span class="fc" id="L44">    private final LongSummaryStatistics responseSizeStats = new LongSummaryStatistics();</span>
<span class="fc" id="L45">    private final Map&lt;String, Long&gt; resourceCountMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L46">    private final Map&lt;Integer, Integer&gt; responseCodeCountMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L47">    private final List&lt;Long&gt; sampledResponseSizes = new ArrayList&lt;&gt;();</span>

    /**
     * Обрабатывает лог Nginx, обновляя статистику размера ответа, счетчики ресурсов и кодов ответов.
     *
     * @param log                  Лог Nginx, содержащий информацию о запросе.
     * @param responseSizeStats    Статистика по размерам ответов.
     * @param resourceCountMap     Карта, хранящая количество запросов к каждому ресурсу.
     * @param responseCodeCountMap Карта, хранящая количество ответов для каждого кода состояния.
     * @param sampledResponseSizes Список, хранящий выборочные размеры ответов.
     */
    public void processLog(
        NginxLog log,
        LongSummaryStatistics responseSizeStats,
        Map&lt;String, Long&gt; resourceCountMap,
        Map&lt;Integer, Integer&gt; responseCodeCountMap,
        List&lt;Long&gt; sampledResponseSizes
    ) {
<span class="fc" id="L65">        long responseSize = log.responseSize();</span>
<span class="fc" id="L66">        responseSizeStats.accept(responseSize);</span>

<span class="fc" id="L68">        resourceCountMap.merge(log.resource(), 1L, Long::sum);</span>
<span class="fc" id="L69">        responseCodeCountMap.merge(log.statusCode(), 1, Integer::sum);</span>

<span class="fc" id="L71">        updateSampledResponseSizes(sampledResponseSizes, responseSize);</span>
<span class="fc" id="L72">    }</span>

    /**
     * Обновляет выборочные размеры ответов. Если размер выборки меньше заданного значения,
     * добавляет новый размер. В противном случае заменяет случайный элемент в выборке.
     *
     * @param sampledResponseSizes Список выборочных размеров ответов.
     * @param responseSize         Размер ответа для добавления или замены.
     */
    public void updateSampledResponseSizes(List&lt;Long&gt; sampledResponseSizes, long responseSize) {
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (sampledResponseSizes.size() &lt; SAMPLE_SIZE) {</span>
<span class="fc" id="L83">            sampledResponseSizes.add(responseSize);</span>
        } else {
<span class="nc bnc" id="L85" title="All 2 branches missed.">            if (RAND.nextDouble() &lt; SAMPLE_PROBABILITY) {</span>
<span class="nc" id="L86">                int indexToReplace = RAND.nextInt(SAMPLE_SIZE);</span>
<span class="nc" id="L87">                sampledResponseSizes.set(indexToReplace, responseSize);</span>
            }
        }
<span class="fc" id="L90">    }</span>

    /**
     * Генерирует метрики на основе статистики размеров ответов, выборочных данных,
     * счетчиков ресурсов и кодов ответов.
     *
     * @param responseSizeStats    Статистика по размерам ответов.
     * @param sampledResponseSizes Список выборочных размеров ответов.
     * @param resourceCountMap     Карта, хранящая количество запросов к каждому ресурсу.
     * @param responseCodeCountMap Карта, хранящая количество ответов для каждого кода состояния.
     * @param startDate            Дата начала периода.
     * @param endDate              Дата окончания периода.
     * @return Объект Metrics с вычисленными метриками.
     */
    public Metrics generateMetrics(
        LongSummaryStatistics responseSizeStats,
        List&lt;Long&gt; sampledResponseSizes,
        Map&lt;String, Long&gt; resourceCountMap,
        Map&lt;Integer, Integer&gt; responseCodeCountMap,
        String startDate,
        String endDate
    ) {
<span class="fc" id="L112">        long logsQuantity = responseSizeStats.getCount();</span>
<span class="fc" id="L113">        long averageResponseSize = (long) responseSizeStats.getAverage();</span>
<span class="fc" id="L114">        final double percent95 = 0.95;</span>
<span class="fc" id="L115">        long percentile95 = calcPercentile(sampledResponseSizes, percent95);</span>
<span class="fc" id="L116">        final double percent50 = 0.50;</span>
<span class="fc" id="L117">        long median = calcPercentile(sampledResponseSizes, percent50);</span>
<span class="fc" id="L118">        final double percent25 = 0.25;</span>
<span class="fc" id="L119">        long percentile25 = calcPercentile(sampledResponseSizes, percent25);</span>
<span class="fc" id="L120">        Map&lt;String, Long&gt; popularResources = findMostPopularResources(resourceCountMap);</span>
<span class="fc" id="L121">        Map&lt;Integer, Integer&gt; topResponseCodes = findTopResponseCodes(responseCodeCountMap);</span>

<span class="fc" id="L123">        return new Metrics(logsQuantity, averageResponseSize, percentile95, median, percentile25, popularResources,</span>
            topResponseCodes, startDate, endDate);
    }

    /**
     * Вычисляет процентиль для списка выборочных размеров ответов.
     *
     * @param sampledResponseSizes Список выборочных размеров ответов.
     * @param percent              Процентиль для вычисления (например, 0.95 для 95-го перцентиля).
     * @return Значение процентиля.
     */
    public long calcPercentile(List&lt;Long&gt; sampledResponseSizes, double percent) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (sampledResponseSizes.isEmpty()) {</span>
<span class="fc" id="L136">            return 0;</span>
        }

<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (sampledResponseSizes.size() == 1) {</span>
<span class="fc" id="L140">            return sampledResponseSizes.getFirst();</span>
        }

<span class="fc" id="L143">        Collections.sort(sampledResponseSizes);</span>
<span class="fc" id="L144">        int index = (int) Math.ceil(sampledResponseSizes.size() * percent) - 1;</span>
<span class="fc" id="L145">        return sampledResponseSizes.get(index);</span>
    }

    /**
     * Находит самые популярные ресурсы на основе карты количества запросов к ресурсам.
     *
     * @param resourceCountMap Карта, хранящая количество запросов к каждому ресурсу.
     * @return Карта с самыми популярными ресурсами и их количеством запросов.
     */
    @SuppressWarnings(&quot;IllegalIdentifierName&quot;)
    public Map&lt;String, Long&gt; findMostPopularResources(Map&lt;String, Long&gt; resourceCountMap) {
<span class="fc" id="L156">        PriorityQueue&lt;Map.Entry&lt;String, Long&gt;&gt; minHeap = new PriorityQueue&lt;&gt;(</span>
<span class="fc" id="L157">            Comparator.comparingLong(Map.Entry::getValue)</span>
        );

<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (Map.Entry&lt;String, Long&gt; entry : resourceCountMap.entrySet()) {</span>
<span class="fc" id="L161">            minHeap.offer(entry);</span>

<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (minHeap.size() &gt; NUMBER_OF_TOP_RESOURCE) {</span>
<span class="fc" id="L164">                minHeap.poll();</span>
            }
<span class="fc" id="L166">        }</span>

<span class="fc" id="L168">        Map&lt;String, Long&gt; result = new LinkedHashMap&lt;&gt;(minHeap.size());</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">        while (!minHeap.isEmpty()) {</span>
<span class="fc" id="L171">            Map.Entry&lt;String, Long&gt; entry = minHeap.poll();</span>
<span class="fc" id="L172">            result.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L173">        }</span>

<span class="fc" id="L175">        return result.entrySet().stream()</span>
<span class="fc" id="L176">            .sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed())</span>
<span class="fc" id="L177">            .collect(Collectors.toMap(</span>
                Map.Entry::getKey,
                Map.Entry::getValue,
<span class="nc" id="L180">                (e1, _) -&gt; e1,</span>
                LinkedHashMap::new
            ));
    }

    /**
     * Анализирует логи Nginx с учетом фильтров по ресурсам и датам.
     *
     * @param logStream    Поток логов Nginx для анализа.
     * @param filters      Карта фильтров, применяемых к логам.
     * @param startDateStr Строка, представляющая дату начала диапазона.
     * @param endDateStr   Строка, представляющая дату окончания диапазона.
     * @return Объект Metrics, содержащий результаты анализа логов.
     */
    public Metrics analyzeLogsWithResourceAndDateFilter(
        Stream&lt;NginxLog&gt; logStream, Map&lt;String, String&gt; filters,
        String startDateStr, String endDateStr
    ) {
<span class="fc" id="L198">        DateFilter dateFilter = new DateFilter();</span>
<span class="fc" id="L199">        dateFilter.setDateFromTo(startDateStr, endDateStr);</span>

<span class="fc" id="L201">        logStream</span>
<span class="fc" id="L202">            .filter(log -&gt; dateFilter.isWithinRange(log.timestamp()))</span>
<span class="fc" id="L203">            .filter(log -&gt; applyFilters(log, filters))</span>
<span class="fc" id="L204">            .forEach(log -&gt; processLog(log, responseSizeStats, resourceCountMap, responseCodeCountMap,</span>
                sampledResponseSizes));

<span class="fc" id="L207">        return generateMetrics(responseSizeStats, sampledResponseSizes, resourceCountMap, responseCodeCountMap,</span>
            startDateStr, endDateStr);
    }

    /**
     * Находит самые популярные коды ответов на основе карты количества кодов ответов.
     *
     * @param responseCodeCountMap Карта, хранящая количество ответов для каждого кода состояния.
     * @return Карта с самыми популярными кодами ответов и их количеством.
     */
    @SuppressWarnings(&quot;IllegalIdentifierName&quot;)
    protected Map&lt;Integer, Integer&gt; findTopResponseCodes(Map&lt;Integer, Integer&gt; responseCodeCountMap) {
<span class="fc" id="L219">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; minHeap = new PriorityQueue&lt;&gt;(</span>
            NUMBER_OF_TOP_RESPONSE_CODES,
<span class="fc" id="L221">            Map.Entry.comparingByValue()</span>
        );

<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, Integer&gt; entry : responseCodeCountMap.entrySet()) {</span>
<span class="fc" id="L225">            minHeap.offer(entry);</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">            if (minHeap.size() &gt; NUMBER_OF_TOP_RESPONSE_CODES) {</span>
<span class="nc" id="L228">                minHeap.poll();</span>
            }
<span class="fc" id="L230">        }</span>

<span class="fc" id="L232">        Map&lt;Integer, Integer&gt; topResponseCodes = new LinkedHashMap&lt;&gt;(minHeap.size());</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        while (!minHeap.isEmpty()) {</span>
<span class="fc" id="L234">            Map.Entry&lt;Integer, Integer&gt; entry = minHeap.poll();</span>
<span class="fc" id="L235">            topResponseCodes.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L236">        }</span>

<span class="fc" id="L238">        return topResponseCodes;</span>
    }

    /**
     * Анализирует логи Nginx с учетом заданных фильтров по ресурсам.
     *
     * @param logStream Поток логов Nginx для анализа.
     * @param filters   Карта фильтров, применяемых к логам.
     * @return Объект Metrics, содержащий результаты анализа логов.
     */
    public Metrics analyzeLogsWithResourceFilter(
        Stream&lt;NginxLog&gt; logStream, Map&lt;String, String&gt; filters
    ) {
<span class="nc" id="L251">        logStream.filter(log -&gt; applyFilters(log, filters))</span>
<span class="nc" id="L252">            .forEach(log -&gt; processLog(log, responseSizeStats, resourceCountMap, responseCodeCountMap,</span>
                sampledResponseSizes));

<span class="nc" id="L255">        return generateMetrics(responseSizeStats, sampledResponseSizes, resourceCountMap, responseCodeCountMap,</span>
            &quot;-&quot;, &quot;-&quot;);
    }

    /**
     * Применяет заданные фильтры к логам Nginx.
     *
     * @param log     Лог Nginx для проверки.
     * @param filters Карта фильтров, применяемых к логам.
     * @return true, если лог соответствует всем фильтрам; иначе false.
     */
    protected boolean applyFilters(NginxLog log, Map&lt;String, String&gt; filters) {
<span class="fc" id="L267">        return filters.entrySet().stream().allMatch(entry -&gt; {</span>
<span class="fc" id="L268">            String filterKey = entry.getKey();</span>
<span class="fc" id="L269">            String filterValue = entry.getValue();</span>
<span class="pc bpc" id="L270" title="9 of 10 branches missed.">            return switch (filterKey) {</span>
<span class="nc" id="L271">                case &quot;ipAddress&quot; -&gt; log.ipAddress().equals(filterValue);</span>
<span class="nc" id="L272">                case &quot;userIdentifier&quot; -&gt; log.userIdentifier().equals(filterValue);</span>
<span class="nc" id="L273">                case &quot;userId&quot; -&gt; log.userId().equals(filterValue);</span>
<span class="nc" id="L274">                case &quot;timestamp&quot; -&gt; log.timestamp().equals(filterValue);</span>
<span class="nc" id="L275">                case &quot;requestMethod&quot; -&gt; log.requestMethod().equals(filterValue);</span>
<span class="fc" id="L276">                case &quot;resource&quot; -&gt; log.resource().equals(filterValue);</span>
<span class="nc" id="L277">                case &quot;httpVersion&quot; -&gt; log.httpVersion().equals(filterValue);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                case &quot;statusCode&quot; -&gt; log.statusCode() == Integer.parseInt(filterValue);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                case &quot;responseSize&quot; -&gt; log.responseSize() == Long.parseLong(filterValue);</span>
<span class="nc" id="L280">                default -&gt; true;</span>
            };
        });
    }

    /**
     * Анализирует логи Nginx с учетом диапазона дат.
     *
     * @param logStream    Поток логов Nginx для анализа.
     * @param startDateStr Строка, представляющая дату начала диапазона.
     * @param endDateStr   Строка, представляющая дату окончания диапазона.
     * @return Объект Metrics, содержащий результаты анализа логов.
     */
    public Metrics analyzeLogsWithDateFilter(Stream&lt;NginxLog&gt; logStream, String startDateStr, String endDateStr) {
<span class="nc" id="L294">        DateFilter dateFilter = new DateFilter();</span>
<span class="nc" id="L295">        dateFilter.setDateFromTo(startDateStr, endDateStr);</span>

<span class="nc" id="L297">        logStream</span>
<span class="nc" id="L298">            .filter(log -&gt; dateFilter.isWithinRange(log.timestamp()))</span>
<span class="nc" id="L299">            .forEach(log -&gt; processLog(log, responseSizeStats, resourceCountMap, responseCodeCountMap,</span>
                sampledResponseSizes));

<span class="nc" id="L302">        return generateMetrics(responseSizeStats, sampledResponseSizes, resourceCountMap, responseCodeCountMap,</span>
            startDateStr, endDateStr);
    }

    /**
     * Анализирует все логи Nginx без применения фильтров.
     *
     * @param logStream Поток логов Nginx для анализа.
     * @return Объект Metrics, содержащий результаты анализа логов.
     */
    public Metrics analyzeLogs(Stream&lt;NginxLog&gt; logStream) {
<span class="nc" id="L313">        logStream.forEach(</span>
<span class="nc" id="L314">            log -&gt; processLog(log, responseSizeStats, resourceCountMap, responseCodeCountMap, sampledResponseSizes));</span>

<span class="nc" id="L316">        return generateMetrics(responseSizeStats, sampledResponseSizes, resourceCountMap, responseCodeCountMap, &quot;-&quot;,</span>
            &quot;-&quot;);
    }

    public LongSummaryStatistics getResponseSizeStats() {
<span class="fc" id="L321">        return responseSizeStats;</span>
    }

    public Map&lt;String, Long&gt; getResourceCountMap() {
<span class="fc" id="L325">        return resourceCountMap;</span>
    }

    public Map&lt;Integer, Integer&gt; getResponseCodeCountMap() {
<span class="fc" id="L329">        return responseCodeCountMap;</span>
    }

    public List&lt;Long&gt; getSampledResponseSizes() {
<span class="fc" id="L333">        return sampledResponseSizes;</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>